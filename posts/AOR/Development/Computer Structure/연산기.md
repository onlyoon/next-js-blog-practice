#aor 
### Arithmetic and Logical Unit
>[!note]
>#### 산술 논리 연산 장치
>
>>데이터 처리를 위한 명령어를 담당하는 장치이다.

- 산술 논리 장치의 연산된 결과는 레지스터 또는 기억장치에 저장되고, [상태 레지스터](상태%20레지스터.md)에 기록된다.
- 산술 연산 혹은 논리 연산이 가능하다.

#### 연산의 종류
- 단항 연산자
	- 계산에 사용되는 항의 수가 한 개인 연산자이다.
- 이항 연산자
	- 계산에 사용되는 항으 수가 두 개인 연산자이다.

### 산술 연산 (`+`, `-`, `*`, `/`)
#### 산술 연산 수의 종류
- 부호가 없는 수(양수)
	- 논리 연산, 시프트 연산, 산술 연산이 가능하다.
- 부호가 있는 수(정수)
	- 정수에 대하여, 산술시프트 연산, 산술 연산이 가능하다.
- 실수
	- 산술 연산이 가능하다.

#### 부호가 있는 수(정수) 표현
##### 부호화 크기(signed magnitude)
- 가장 왼쪽의 비트(MSB)에 부호 비트(sign bit)를 사용한다.
- 부호 비트가 0일 경우: 양수
- 부호 비트가 1일 경우: 음수
- MSB를 뺀 나머지 비트가 수의 크기를 나타낸다.

- 부호화 크기로 표현할 수 있는 n비트 수의 표현 범위
![](../../../Stuff/Image/AOR/Computer%20Structure/Pasted%20image%2020231011185814.png)
##### 1의 보수(1's complement)
- 1->0, 0->1로 변경한다.

##### 2의 보수(2's complement)
- 정수 표현의 표준이다.
- 1의 보수에서 1을 더한다.

- 2의 보수로 표현할 수 있는 n비트 수의 표현 범위
![](../../../Stuff/Image/AOR/Computer%20Structure/Pasted%20image%2020231011190139.png)

#### 산술 연산
- 단항 산술 연산
	- 2의 보수화
	- 증가
	- 감소
- 이항 산술 연산
	- 덧셈
	- 뺄셈
	- 곱셈
	- 나눗셈
##### 덧셈
>ADD R1, R2 // $R1 = R1 + R2$
- 연산 결과가 수의 표현 범위를 벗어날 때, 오버플로우 발생
- 정수 표현 범위 `-128 ~ 127`
##### 뺄셈
>SUB R1, R2 // $R1 = R1 - R2 = R1 + (-R2) = R1 + (R2에 대한 2의 보수)$
- 연산 결과가 수의 표현 범위를 벗어날 때, 오버플로우 발생
- 정수 표현 범위 `-128 ~ 127`
### 논리 연산 (`NOT`, `AND`,  `OR`, `XOR`)
#### `NOT` 연산
> 오퍼랜드 각 비트에 대해 `NOT`연산을 수행한다.
- 오퍼랜드에 대한 1의 보수와 같다.
#### `AND` 연산
> 마스크 연산 === `AND`연산
- 마스크 연산은 일부 비트만 남기고 나머지는 0으로 채우는 연산을 말한다.
#### `OR` 연산
> 선택적 세트 연산 === `OR`연산
- 선택적 세트 연산은 비트 중에서 일부 비트는 그대로 두고, 특정 비트를 1로 세트하는 연산을 말한다.
#### `XOR` 연산
>두 개의 오퍼랜드에 대하여 `XOR`연산을 수행한다.
#### 시프트 연산
>레지스터 내의 데이터 비트를 왼쪽이나 오른쪽 둘 중 하나의 방향으로 한 비트씩 이동하는 것을 말한다.

- 시프트 연산 종류 세가지
	- 논리 시프트
	- 산술 시프트
	- 회전
##### 논리 시프트
- 이동하고 남는 자리에 0이 추가된다.
##### 산술 시프트
- 부호 있는 수일 경우,
	- `LEFT` 시프트: 이동하고 남는 자리에 0이 추가된다.
		- 곱하기와 동일
	- `RIGHT` 시프트: 이동하고 남는 자리에 부호가 추가된다.
		- 나누기와 동일
##### 회전
- 부호 없는 수일 경우,
	- 끝단의 비트를 시프트 한 후, 버리지 않고, 마지막 비트 위치로 이동
### [Computer Structure](../../Dev-Index/Computer%20Structure.md) Index로 돌아가기